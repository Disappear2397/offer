动态规划思想(自底向上)包括递推和递归思想，也就是找规律做选择，找出转移方程  划分子问题与合并
        贪心算法是动态规划的一个子集，能从局部最优推导出全局最优就是贪心，否则就是动态规划

回溯(自顶向下)：是一种算法思想，用递归来实现的，调用自身往回走，类似于穷举  往往需要剪枝（边界问题）
滑动窗口是一种动态规划实现方式

正则表达式？？ 表示数值的字符串 剑指20



将多维数组转换成字符串用deepToString

二叉查找树，也称二叉搜索树，或二叉排序树 全部左小右大
平衡二叉树它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) <O(n^3) < O(2^n) < O(n!) < O(n^n)

回溯题型模板：
        result={}存放结果
        void backtrack(此时已经走完的路径，此次可选择的选择列表){
            if 满足结束条件：
                result.add(路径)；
                return；//一定要加，这个表示这个方向的结束；
            for（int i=0;i<选择列表长度；i++）{//这里要遍历所有的选择，将所有的选择考虑进去
                if 是否满足需求：
                    放入已经走完的路径里；
                else
                    continue;
                backtrack（此时已经走完的路径，此时的选择列表）；//注意这里的选择列表已经发生了变化，是刚放进路径的节点下一步的所有选择
                撤销上一步的路径；
            }
        }

调用HashSet的add方法实质上是调用HashMap的put方法，map是全局，变量它指向的是在创建HashSet对象时创建的HashMap对象。
如果put方法返回值为null则add方法返回true，证明添加成功；如果put方法返回值非null则add方法返回false，证明添加失败。

protect关键字内涵：
    就是:被protected修饰的成员对于本包和其子类可见
    注意：1基类的protected成员是包内可见的，并且对子类可见；
    2.若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法


try{
    //代码执行区域
}catch(Exception e){
    //异常处理区域
}finally{
    //无论如何都会执行的代码区域
}