package com.leetcode;

import java.util.Scanner;

/**
 * @author LJ
 * @version 1.0
 * @date 2022/3/4 19:24
 */
public class 双蛋掉落{
    //已知两个蛋求出能得到摔坏楼层的扔蛋次数
    public static int twoEggDrop(int n) {
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {//假设当前的总层数
            dp[i] = Integer.MAX_VALUE;
            for (int j = 1; j <= i; j++) {//尝试扔下的层数
                // dp[i - j] + 1表示第一个鸡蛋没碎的次数，j表示第一个鸡蛋碎了的次数
                dp[i] = Math.min(Math.max(dp[i - j] + 1, j), dp[i]);
            }
        }
        return dp[n];
    }
    //求出哪一层能碎要用数学归纳：解方程法
    //　　这里介绍下解方程法，算法的思想呢是假设最优解是x次，第一次扔的楼层也是x层。为什么第一层扔的楼层也是x层呢？因为如果最优解成立：
    //①当第一次扔的楼层是x+1层时，若碎了，则需要在[1,x]楼层里依次扔出，最坏情况是在x层碎，即尝试次数是：x+1次，和假设不符
    //②当第一次扔的楼层是x-1层时，若碎了，则需要在[1,x-1]层里依次尝试，最快情况是在x-1层碎，即尝试次数是：x-1次，和假设不符
    //　　综上所述，假设最优解是x次时，第一层扔的楼层也得是x层。
    //
    //开始扔鸡蛋了
    //　　第一次是在x层扔鸡蛋，蛋不碎
    //　　第二次得在(x,100]区间内扔鸡蛋了，具体是哪一个层呢？应该是x-1层。为什么是x-1层呢？因为[1,100]区间，尝试次数是x次，在x层不碎，则问题转化成了在(x,100]层，最优解是x-1次，同理，扔鸡蛋的楼层数也得是x-1层。
    //　　第三次得在x-2层
    //　　以此类推…
    //转化成方程式是： x + (x-1) + (x-2) + (x-3) + … + 2 + 1 = 100，左边的都能理解，右边的为什么是100呢？因为楼层是100层，方程式的左边肯定小于等于100，取最坏情况那就是方程式右边是100。
    //　　根据等差数列求和公式Sn=n(a1+an)/2 ，x向上取整得14，即第一次在14层扔，第二次是在 14+(14-1)=27层，第三次是39,50,60,69,77,84,90,95,99,100。当最坏情况是在99层碎了，即尝试次数是10+4=14次。
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int i = scanner.nextInt();
        System.out.println(twoEggDrop(i));
    }
}
